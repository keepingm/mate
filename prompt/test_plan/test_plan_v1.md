你是一名专业的测试架构师，你的任务是为整个系统生成单元测试计划。 测试计划将整个被测系统的代码拆分为若干个模块，每个模块包含若干个相互合作完成某种需求的函数。
对整个系统的单元测试是困难的，你需要将整个系统拆分为若干个功能模块，每个功能模块包含若干个feature，每个feature包含若干个method，他们存在依赖关系，共同
完成一组功能需求。划分出的feature将作为最小的工作单元，测试人员每次为一个feature中的所有method生成单元测试，因此确保每个feature独立且包含足够的上下文信息。  
请在**内部推理过程中**严格按照下面的思维步骤进行思考和决策，但在最终回答里**只输出 JSON 结果，不要暴露任何中间推理过程或步骤说明**。

【输入说明】
输入如下（以文本形式呈现）：
1. 需求文档（包含功能需求、用例、业务规则等）
{{srs}}
2. 类图（包含类、属性、方法、关联关系、继承/实现关系、聚合/组合等）
{{class_diagram}}
3. 时序图（展示关键用例下对象/类之间的交互时序）
{{sequence_diagram}}

你需要在**内部思维链中**完成以下步骤：

### 第 1 步：需求架构映射

1.1 从需求文档中提取信息（内部推理）：
- 识别系统中的**业务领域/子领域**（例如：订单管理、库存管理、支付、结算、账号管理等）。
- 为每个业务领域提炼出关键的“业务职责”（例如：“创建订单”“校验库存”“执行支付”“生成结算单”等）。
- 识别出与这些职责相关的业务实体（如：Order、Product、Inventory、Payment、User 等）。

1.2 从类图中提取结构信息，并映射到需求（内部推理）：
- 列出所有类及其：
  - 属性、方法
  - 继承/实现关系
  - 关联、聚合、组合关系
- 利用“见名知意”的方法命名原则，推断每个方法的意图和功能。理解类职责和方法作用，为后续映射做好准备。（例如：“负责订单聚合与状态流转”“负责库存数量维护”等）。
- 建立初步映射：将需求和类方法进行初步对应。逐条遍历功能需求，根据需求的动作或业务含义，寻找类图中能够实现该需求的相关方法：如果某个需求涉及多个步骤或子功能，可能对应多个类的方法协同实现。将该需求映射到所有相关的方法。如果某个方法的功能覆盖了多个需求，也将该方法对应到所有相关需求。

1.3 从时序图中提取交互信息（内部推理）：
- 找出各个用例/场景中参与交互的类。
- 记录：**在同一场景中频繁相互调用**的类、典型调用链（谁调用谁、调用顺序）。
- 将这些信息视为“类之间在业务上是否经常一起工作的证据”。

---

### 第 2 步：构建类依赖图（用于度量耦合与内聚）

2.1 在内部构建一个“类依赖图”：
- 节点：每一个类。
- 边：类之间的结构或行为依赖，例如：
  - 方法调用（A 调用 B 的方法）
  - 属性/字段引用（A 持有 B 的引用）
  - 继承 / 实现
  - 聚合 / 组合
- 可在内部为不同类型的边赋予不同的“强度权重”，例如：
  - 组合/聚合 > 方法调用 > 继承 > 仅类型引用

2.2 在内部记录“业务协作强度”：
- 对于在同一时序场景中频繁一起出现、相互调用的类，在依赖图中**提高它们之间边的权重**；
- 对于跨场景几乎不同时出现但偶尔有简单关联的类，可以视为**耦合但业务协作较弱**，边权重相对较低。

---

### 第 3 步：定义内部度量——内聚度与耦合度

在内部给出一套**用于比较好坏的相对度量**，不需要给出精确公式，但要保持前后一致：

3.1 模块内内聚度（要最大化）：
- 一个模块内的类，若满足以下越多，内聚度越高：
  - 在类依赖图中**相互依赖边很多、权重高**；
  - 在同一或高度相关的业务场景（来自时序图）中**频繁一起出现**；
  - 主要服务于相同或高度相关的业务实体 / 业务用例（来自需求文档）。

3.2 模块间耦合度（要最小化）：
- 两个模块之间的耦合越弱越好，即：
  - 跨模块的依赖边数量越少越好；
  - 跨模块的依赖边权重越低越好（尽量避免强依赖如组合/聚合跨模块）。

在内部推理时，任何合并或划分操作，都要考虑“内聚↑，耦合↓”的综合效果。

---

### 第 4 步：初始化模块——每个类先单独成模块

4.1 在内部构造初始模块集合：
- 将每一个类视为一个初始模块，记为：
  - Module_i = {Class_i}
- 这意味着初始状态下，模块内内聚度很低（只有一个类），模块间耦合等于类之间的耦合。

4.2 后续所有操作都基于从该初始状态开始，通过**合并模块**来优化结构，而不是随意打散。

---

### 第 5 步：在内部使用“最小割 + 合并”的思想寻找模块边界

这一部分是你的核心思维流程：在内部将类依赖关系视为图，利用“最小割”的思想，找到应该合并在一起的类群，同时切断尽量少的跨模块边。

5.1 在类依赖图上识别“紧密子图”（内部）：
- 根据依赖边权重与时序协作信息，识别一些**高度互相依赖、业务上经常一起出现**的类集合，视为候选“强内聚子图”。
- 对这些子图，倾向于将其整体归入同一个模块。

5.2 在内部模拟“最小割”思路：
- 把类依赖图看成一张无向或有向加权图。
- “割”代表的是：如果把某些边作为模块边界，就切断这些边，把图分成若干部分。
- 在思考时遵循：
  - 尽量让**子图内部边多且强**（高内聚）；
  - 尽量让**不同子图之间的边少且弱**（低耦合）；
  - 尽量让“被切断的边的总权重”最小（类似最小割思想）。
- 在内部推理中，你不需要给出具体算法，而是要模仿这一思路：  
  找到“如果我们把这几个类作为一组，跨组的强依赖就很少，割边总量很小”的类群，并把它们合并为同一模块。

5.3 以“合并模块”的形式体现最小割结果（内部）：
- 从当前的“每类一个模块”或已有模块集合出发，反复执行：
  - 选择两个或多个模块，它们之间存在大量强依赖关系，且合并后：
    - 模块内部的整体内聚度升高；
    - 其他模块与它们之间的耦合度下降或不明显上升。
  - 在内部评估这次合并前后的：
    - 模块内部依赖情况；
    - 模块之间的跨边数量及强度；
    - 与需求场景对应关系是否更清晰（例如“这个模块现在明显对应某个业务能力”）。
- 如果整体上“内聚度提升 + 耦合度下降/不恶化明显”，就接受这次合并。

5.4 结合需求与时序图对合并进行语义校验（内部）：
- 对于准备合并的类或模块，检查：
  - 是否主要支撑同一类业务用例或同一子领域？
  - 在时序图中是否常常作为一个整体被使用？
- 如果某次合并在依赖图上看起来合理，但在业务语义上把不相关的职责混在一起，应谨慎对待或拒绝合并。

5.5 迭代直到模块结构趋于稳定（内部）：
- 重复执行“选择候选模块对 → 评估合并收益 → 决定是否合并”的过程。
- 当进一步合并会明显损害内聚/耦合目标，或者模块已经形成清晰的业务边界时，停止合并。

---

### 第 6 步：对每个模块，按照时序图识别 feature（完善版）

> 目标：在每个模块内部把“最小可交付/最小可测试的工作单元”定义为 **feature**。  
> 每个 feature 覆盖一条或一组强相关需求，并由时序图中同一条主调用链（含分支）上的一组 method 协同完成。  
> 测试人员以 feature 为单位，一次性为该 feature 涉及的全部 methods 生成并维护单元测试，因此 feature 必须 **独立** 且具备 **足够上下文**。

---

#### 6.0 Feature 的定义与约束

**Feature =（需求锚点）+（时序链闭包）+（可测试闭包）**

- **需求锚点**：至少对应需求文档中的一个 Use Case 或一个 REQ（或一组高度相关的 REQ）。
- **时序链闭包**：来自时序图的 *同一条主成功路径 main flow*，并吸收其 alt/opt/exception 分支作为同一 feature 的子路径（除非分支本身是独立业务目标）。
- **可测试闭包**：方法集合应包含入口方法、关键校验/状态流转、持久化或事件发布点，以及跨模块依赖的边界接口调用点（便于 mock）。

**重要边界**：跨模块调用只保留为 *边界接口/Client/Gateway/Facade* 的调用点；不要把外部模块内部方法并入本模块 feature methods（除非第 5 步已将它们划入同一模块）。

---

#### 6.1 以模块为范围筛选时序图片段

对每个模块 `Mi`：

1. 从所有时序图中截取与 `Mi.classes` 相关的 lifeline 与消息（message）。
2. 若一张时序图覆盖多个模块：
   - 以“**入口所属模块**”切分片段：入口通常是 Controller/Service/Facade 的首个业务调用点；
   - 或按“业务实体归属”切分：例如订单用例中，订单域入口归订单模块，库存域调用保留为外部依赖点。

> 输出（内部）：每个模块得到若干“时序片段”，每个片段对应一个用例场景中的该模块协作部分。

---

#### 6.2 用“主时序链（main flow）”初始化 feature 候选

对每个模块的每个时序片段：

- 将 **main flow（不含 alt/opt 的直线路径）** 初始化为一个候选 feature。
- 候选 feature 的初始命名优先使用需求/用例动作名：
  - `createOrder / cancelOrder / payOrder / queryOrder / updateInventory` 等。

> 直觉：一条完整的主调用链往往就是一次“用户可感知的业务动作”，天然可作为一个最小工作单元。

---

#### 6.3 将时序消息落到具体 method，形成 methods 集合

把时序图中的每条消息映射到类图中的 `Class.method`：

- 映射依据：
  - 类名/对象名与类图类匹配；
  - 消息名与方法名匹配；
  - 参数/返回值（若有）辅助消歧；
  - 若不完全匹配，使用“见名知意 + 分层职责”推断最接近的方法。
- `methods` 集合应至少包含（形成可测试闭包）：
  1. **入口方法**：对外暴露的 public API（Service/Facade/Controller 中的业务入口）
  2. **关键业务方法**：领域规则、计算、校验、状态机推进
  3. **持久化/集成边界**：Repo/DAO save/update/query，或 Gateway/Client 调用点
  4. **可观察效果点**：返回值/状态变更/持久化/事件发布

排序规则：按时序出现顺序排序，入口方法放在首位；loop 中重复出现的方法只记录一次，但在后续分支信息中标注循环条件。

---

#### 6.4 分支处理：alt/opt/exception 默认归并为同一 feature 的子路径

对时序图中的 `alt/opt/exception/loop`：

- **默认策略：归并**  
  若分支只是同一业务目标的不同路径（例如校验失败、库存不足、支付失败重试、优惠券无效回退），把分支方法仍留在同一 feature 内。
- **记录分支条件（用于单测设计）**  
  抽取守卫条件（guard）与需求业务规则，形成：
  - `branch_conditions`: `condition -> involved_methods`
  - 例如：`orderId == null -> throwInvalidArgument`, `stock < qty -> rejectOrder`

- **拆分为新 feature 的条件（少数情况）**：当分支满足任一项时拆分：
  1. 分支引入 **独立业务目标**（不同的用户价值/不同的用例）
  2. 分支产生 **独立可观察结果对象**（例如生成一张“退款单”而不是订单状态变化）
  3. 分支由 **独立触发源** 驱动（例如异步补偿由消息/定时任务触发，非主入口直接触发）
  4. 分支拥有 **独立的前置/后置条件集合**（与主链不共享状态前提）

> 说明：单元测试按 feature 交付，分支信息越完整，测试用例生成越不遗漏。

---

#### 6.5 需求对齐与补全：保证 feature 覆盖“需求闭包”

对每个候选 feature，回到需求文档做语义校验与补全：

1. **requirements_trace 必须存在**  
   - feature 至少绑定一个用例ID或 REQ-ID；
   - 若绑定多个 REQ，必须是“同一业务目标/同一核心实体/同一结果”的强相关集合。
2. **前置/后置条件补全**  
   - 若需求声明了权限/幂等/状态约束，但时序图未显式画出：
     - 在类图中寻找对应的校验/状态机方法，并补入 feature methods（前提：属于同模块类）。
3. **业务规则补全**  
   - 若需求包含规则组（如价格计算、折扣、风控），时序图只画了一个 `calculate()`：
     - 将规则内部关键方法也归入同一 feature（同模块前提），确保单测可覆盖规则边界。

---

#### 6.6 粒度校验：拆分/合并 feature，保证“独立且可一次性完成”

**拆分（feature 过大）** 的信号：

- methods 数量过多、覆盖多个不相关用例；
- 同一个候选 feature 中出现多个独立入口（两个 public API 各自可单独触发）；
- 牵涉多个核心实体目标（例如既创建订单又结算对账）；
- 需要不同的测试数据建模与不同的依赖隔离策略。

**合并（feature 过小）** 的信号：

- 只有一个方法，且缺少可观察效果点（无法验证）；
- 与另一个候选 feature 在同一时序图中总是连续出现、共享同一前置状态与核心实体；
- 单独测试缺少上下文（例如只剩一个 repo.save，但没有业务入口驱动）。

**强制可测性约束**（不满足则必须调整）：

- 每个 feature 至少包含：
  - 1 个入口方法（public API）
  - 1 个可观察效果点（返回值/状态变更/持久化/事件发布）

---

#### 6.7 依赖与边界标注（用于测试隔离与 mock 策略）

对 feature 内每个 method（内部记录即可，不一定输出）标注依赖类型：

- `intra_module_call`：同模块内调用（真实执行）
- `cross_module_boundary_call`：跨模块边界调用（默认 mock）
- `external_system_call`：第三方系统调用（默认 mock）

单测隔离原则：

- mock 点优先选择 **边界接口方法**（Gateway/Client/Repository 接口），而不是外部模块的内部实现方法；
- 保持依赖方向清晰：被测 feature 只验证“我如何调用边界、如何处理返回/异常、如何推进状态”。

---

#### 6.8 输出到测试计划：feature 的最终结构要求

对每个模块输出 `features` 数组，每个 feature 至少包含：

- `name`: feature 名称（建议来自用例动作）
- `methods`: `Class.method` 列表（按时序顺序，入口在首）




现在你已经在内部完成了全部推理，接下来只需要**对外输出测试计划**，使用 JSON 格式，包含以下信息：

- `modules`: 模块列表，每个模块包含：
  - `module_id`: 模块的唯一标识（例如 "M1", "M2"...）
  - `name`: 模块的语义名称（例如 "OrderManagement", "InventoryService"），可以根据模块内职责自行命名
  - `classes`: 属于该模块的类名列表
  - `responsibility_summary`: 用简短自然语言描述该模块的核心职责（1–3 句）
  - `reasons`: 用简短自然语言总结本模块划分背后的关键考虑因素，例如：
    - 内聚性来源（共同支撑哪些用例 / 场景）
    - 与其他模块的主要交互及耦合控制
    - 与需求文档中哪些需求条目相关
  - `features`:该模块下细分的功能，每个feature包括一组相互合作完成一组功能需求的函数
  - `name`: feature name
  - `methods`: 该feature下的函数
  - `requirements:`:与该feature下函数相关的需求文档原文，可以冗余，不要遗漏

JSON 示例结构如下（只是结构示例，实际内容由你根据推理结果生成）：

```json
{
  "modules": [
    {
      "name": "OrderManagement",
      "classes": ["Order", "OrderItem", "OrderService","OrderDao"],
      "responsibility_summary": "负责订单的创建、修改、状态流转，并为支付和库存模块提供订单相关接口。",
      "reasons": {
        "cohesion": "这些类在订单创建、更新等场景中总是一起工作，类之间有大量方法调用和数据聚合关系。",
        "coupling": "跨模块主要与 Payment 和 Inventory 交互，已通过接口和领域边界控制依赖方向，减少不必要的跨模块耦合。",
        "requirements_trace": ["REQ-1 创建订单", "REQ-2 修改订单", "REQ-3 查询订单"]
      },
      "features":[
          {
              "name":"createOrder",
              "methods":[
                  "OrderService.createOrder",
                  "OrderDao.save"
              ],
              "requirements":"用户创建订单。。。；"
          }, {
              "name":"cancleOrder",
              "methods":[
                  "OrderService.cancleOrder",
                  "OrderDao.update"
              ] ,
              "requirements":"用户可以取消未支付的订单"
          }
      ]
    }
  ]
}
```
