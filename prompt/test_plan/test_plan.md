你是一名专业的测试架构师，你的任务是为整个系统生成单元测试计划,测试计划将整个被测系统的代码拆分为若干个模块，每个模块包含若干个相互合作完成某种需求的类/函数，各模块之间的交互通过接口契约来模拟。每次生成测试用例时只需深入理解当前的模块代码和需求，而无需通读整个系统的需求文档或代码库，提高效率，减少认知负担。同时，模块间尽量解耦也避免了缺陷的蔓延，使问题定位和调试更快捷。

请在**内部推理过程中**严格按照下面的思维步骤进行思考和决策，但在最终回答里**只输出 JSON 结果，不要暴露任何中间推理过程或步骤说明**。

**输入说明：** 输入如下（以文本形式呈现）：

1. 需求文档（包含功能需求、用例、业务规则等）
 {{srs}}
2. 类图（包含类、属性、方法、关联关系、继承/实现关系、聚合/组合等） 
 {{class_diagram}}
3. 时序图（展示关键用例下对象/类之间的交互时序）
 {{sequence_diagram}}

# 步骤1：审阅项目资料

对输入文档进行全面审阅。充分理解系统的结构和功能，以奠定划分模块的基础。具体操作包括： 

阅读需求规格说明：通读需求文档，了解系统的主要功能模块、业务领域和业务流程。在此过程中，尝试在脑海中勾勒系统的功能板块。例如，把需求按照功能域分类，如“用户管理”“订单处理”“库存管理”等，为后续模块划分提供初步思路。

 研读设计和架构文档：查看系统的总体设计说明和UML模型（类图、时序图）。重点关注类图中的包结构、类之间的关联和依赖关系，找出高度相关的一组类（这往往预示着一个模块），以及哪些部分耦合度较低。

留意接口和边界：设计文档中如果明确了子系统/模块边界和接口，那将是直接的划分依据 。 

记录初步印象：在审阅过程中，列出潜在的模块候选名单和对应的功能描述。例如：“模块A：用户认证与授权（涉及User、AuthService类...）”“模块B：购物车管理（涉及Cart、Item、CartService类...）”等等。此时只是粗粒度的直觉划分，后续步骤会再细化和验证。

注意：如果系统已经有明确的模块化结构（例如微服务架构中的各服务，或者传统分层架构中的子系统），可将这些现有模块视为划分基础。然而仍需检视这些模块的内部耦合和对外依赖，确保它们符合独立测试的要求。如果架构没有明确模块划分，则需要通过上述仔细研读来抽象出合理的模块。
# 步骤2：识别并定义模块边界 
根据对资料的理解，正式确定系统的模块划分方案。这一步需要应用高内聚、低耦合原则，将类和功能分组成适当的模块：

**基于功能聚类**：回顾需求文档，将功能需求划分到前一步列出的模块候选中。每个模块应对应一组相关的功能或用例。例如，用户相关的需求归入“用户模块”，财务结算需求归入“支付模块”等。这样确保模块有清晰的功能主题，其内部元素围绕该主题展开（功能内聚）。 

**基于结构聚类：**
量化指标：
1. 耦合度：Inter-Module Coupling (InterMD)
度量的是模块之间的依赖条数：如果模块 A 中某个类调用了模块 B 中某个类，就算一条 A→B 的依赖。InterMD = 所有模块对其它模块依赖的总数之和。
目标：越小越好 —— 对应“低耦合”。
2. 内聚：Intra-Module Coupling (IntraMD)
IntraMD 衡量模块内类之间的依赖，定义为：模块内实际存在的依赖数 ÷ 模块内理论上可能的最大依赖数。模块内理论上可能的最大依赖数为模块内的完全图的边的数量。
目标：越大越好 —— 对应“高内聚”。
利用类图和依赖分析，将关系密切的类归为一组，最大化内聚度，最小化耦合度。如果某些类之间有大量的调用、继承或关联关系，说明它们可能属于同一模块。例如，Order类和OrderItem、OrderService类相互协作频繁，则可放在同一模块“订单处理模块”。这样模块内部的类联系紧密，而不同模块之间联系相对较少。

验证内聚性：检查每个模块内的元素是否共同实现单一的功能目标，避免把不相关的功能混杂在一个模块中。例如，不要把“报告生成功能”的类混入“用户管理模块”。如果发现某模块承担了过多不相关职责，考虑再细分成更小的模块，以提高内聚度。模块粒度的大小要平衡：既不能过大导致测试人员负担过重，也不能过碎导致模块间交互剧增。可以借鉴单一职责原则：一个模块尽可能只负责一块明确的业务功能。 

评估低耦合：审视模块之间的依赖关系。尽量使模块间的直接调用或数据共享最少。如果发现两个模块之间交互频繁（高耦合），思考是否有必要调整边界：

合并或重新划分：如果某两个模块A和B之间大量函数调用，你可能需要将这些类划为同一模块，或者按不同方式拆分功能，以减少跨模块调用次数。模块划分不是一开始就固定的，可以根据耦合度反馈进行调整。

提取公共组件：如果很多模块都依赖同一个组件/类（例如公共工具类、基础库），可以将该组件单独视为一个“公共模块”由专人测试，或者在测试时对其进行模拟，以免造成模块之间的强依赖。

明确模块接口：为每个模块划定边界后，确定它对外提供的接口和所需的外部接口。例如：“订单模块提供创建订单接口，依赖库存模块的库存查询接口”。记录这些接口说明，有助于后续设计桩模块或模拟。每个模块的边界应该清晰：知道哪些功能属于该模块，哪些超出范围属于其他模块。

经过此步骤，应当形成模块划分清单，其中列明各模块的名称、职责范围以及包含的类。这个清单反映了模块的边界选择依据（功能和依赖考虑）。同时，也产出模块间关系图或依赖表，标识模块之间存在的调用依赖。
# 步骤3：处理类依赖与设计测试桩 
由于现实软件中完全独立的模块并不多，通常仍存在一些跨模块的调用依赖。本步骤聚焦于应对模块之间的依赖，保证各模块测试能够在隔离状态下进行。主要措施包括：

分析依赖方向：利用前一步的模块关系图，分析每对模块依赖的方向性和重要性。例如，模块A调用模块B的服务，但B不调用A（单向依赖），或者模块X和Y相互都有调用（双向耦合）。优先处理双向或复杂依赖的情况。对于单向依赖，测试时在被调用一侧模拟依赖即可。

确定桩模块/模拟策略：为断开模块依赖，决定在单元测试中如何模拟对其他模块的调用。典型方法有：

使用桩（Stub）和驱动（Driver）：在模块测试中，用桩函数替代未实现或不在本模块范围的被调模块功能；用驱动程序调用待测模块以提供测试输入  。例如，订单模块测试时，用一个伪造的库存查询桩来模拟库存模块返回的数据。

使用Mock对象：借助测试框架创建模拟对象，伪装依赖模块的行为 。Mocks 更加强大，可以针对不同测试用例设置期望的交互和返回值。例如，对外部支付服务创建Mock，模拟各种支付成功/失败情景。

模拟数据或接口契约：如果无法使用代码桩，也可通过提供模拟的数据文件、配置等让待测模块“误以为”在跟真实模块交互。例如提供一个本地配置替代真正的远程服务。

在测试计划中记录依赖处理方案：对于每个模块，在其测试任务清单中记载需要模拟的外部依赖和采用的方法（桩或Mock）。同时确保测试人员具备使用该Mock/桩的指导。例如：“本模块调用了模块B的接口，将通过提供模拟类BServiceStub来替代真实调用  ”。

验证模块可独立测试：经过桩模块设计后，检查是否每个模块都具备独立测试的条件：也就是可以在缺少其他模块实际运行的情况下，通过模拟来满足其外部依赖，从而完成自身功能的验证。如果仍有模块无法离开其他模块就测试，比如存在紧耦合环路，需回到模块划分步骤调整设计，直到消除这种紧耦合。

考虑数据和环境依赖：除了模块调用，还有其他依赖需要处理，如数据库、文件系统、外部API等。在单元测试任务划分中，也应视这些外部系统为“外部模块”，采用类似桩或模拟的方法处理，保证测试环境的可控和独立。记录每个模块测试是否需要特殊的测试环境准备（例如需要嵌入式环境模拟、配置模拟服务器等）。

通过这一步，我们为每个模块的测试创造了隔离的条件。测试工程师在执行自己模块的单元测试时，可以使用预先约定的桩和Mock来模拟外部交互，从而不必了解其他模块的内部实现即可验证本模块行为。这正契合了目标：人员专注于自身模块，无需通读全局代码。

# 步骤4：拆解需求并映射到模块 
在明确模块边界和依赖处理之后，需要确保每个模块的测试范围与需求相一致。本步骤将细化需求，使之对应到各模块测试任务，并保证没有遗漏任何需求点：

分解需求规格：将完整的需求文档按照功能或模块相关性进行拆解。最好将需求逐条列出（如需求条目清单、用例清单），然后标注每条需求归属哪个模块负责测试。例如：需求“用户可以修改个人资料”属于“用户模块”，需求“下单时库存不足则提示”属于“订单模块”和“库存模块”协作（主要验证在订单模块，但需要库存模块返回特定结果）。

建立需求-模块映射表：制作一张表格或矩阵，列出需求ID/描述和对应测试模块，一个需求可能对应多个模块参与实现，但通常主要的功能验证归属一个模块的测试。确保每一条需求都出现在映射中 。如果发现某些需求未分配给任何模块测试，则必须决定由哪个模块的测试覆盖，或者拆分成多个部分分别由不同模块验证。

提炼模块需求简述：针对每个模块，编写该模块相关的需求摘要（将完整需求提炼成该模块需要满足的要点）。这部分内容将写入模块测试任务清单的“需求简述”中。例如：“购物车模块需求简述：根据需求文档第3.1节，购物车应支持添加商品、更新数量、删除商品，并在用户登录后保存购物车内容。” 这样测试人员无需阅读整个文档，只需阅读与本模块相关的摘录即可。建议引用需求文档的章节或ID以方便追溯。

对齐测试目标：确保模块的测试目标清晰且全面覆盖其需求。测试目标应描述“验证模块实现了哪些需求”。比如对购物车模块，测试目标包括“验证所有购物车操作功能正确”、“验证购物车约束（如库存校验、数量上限）”、“验证持久化机制正确”等。这样既与需求对应，又指导测试设计重点。

考虑跨模块需求：有些需求或业务流程横跨多个模块（例如“用户下单”涉及用户、订单、库存多个模块）。对于这类情况，在单元测试阶段，将该流程拆解到各模块分别测试其部分功能。例如：用户模块测试用户验证逻辑，订单模块测试订单创建逻辑，库存模块测试库存扣减逻辑；至于整个下单流程的端到端正确性，则留待集成测试验证。在模块测试任务清单中，可以在“注意事项”中注明跨模块的需求点以及该模块在其中承担的职责，以提醒测试人员关注接口契约。

确保覆盖无遗漏：在完成上述映射后，利用需求可追溯矩阵检查测试覆盖率。即纵向列需求，横向列模块测试，勾选标明某需求由哪个模块测试覆盖 。理想情况下，每个需求至少由某个单元测试任务覆盖（或者标注将在集成测试中覆盖），以防出现未测试的功能点。这个矩阵也作为输出的一部分，为管理者和审计提供信心保证。

通过将需求逐一分配到模块并提炼简述，我们确保了测试任务与需求的一致性和完备性。测试工程师拿到自己的任务清单时，其中的需求简述就是他们需要保证实现正确的功能点清单。这一步使得每位测试人员以需求为导向设计测试用例，不会因划分不当而漏测关键需求。

# 步骤5：制定模块测试任务清单 
在完成模块划分、依赖处理方案和需求映射之后，为每个模块编制详细的测试任务清单（Checklist）。这一清单将作为分配给测试人员的具体任务说明，指导他们如何开展该模块的单元测试设计和执行。任务清单应包含以下要素：

模块名称和任务范围：明确指出该测试任务对应的模块名称，并简要描述其功能范围。范围描述应回答“这个模块测试覆盖系统的哪部分功能？” 例如：“购物车模块 – 负责购物车中商品的添加、更新、删除，以及购物车内容的保存和清空等功能。” 这样测试人员清楚本任务边界，不会越界测试其他模块功能。

相关需求简述：列出该模块涉及的需求要点（由上一步提炼而来），用于让测试人员了解该模块必须满足的业务要求 。通常采用条列式说明主要的需求场景。例如：“1) 用户未登录也可将商品加入购物车（访客购物车）；2) 已登录用户的购物车与账户关联，可跨设备保存；3) 添加商品时若库存不足应提示错误；…”等。必要时引用需求文档的编号以便详细查阅。如果需求规格中有业务规则或约束条件（如数量不能为负等），也应包含在简述中。

涉及的类和接口：详细列出该模块包含或主要涉及的代码单元，例如类、函数、模块接口等。例如：“涉及主要类：CartService (提供购物车操作接口)，CartItem (购物车项数据结构)，CartController (接收前端请求) 等；以及相关数据库访问类CartDAO。” 同时列出该模块对外依赖的其他模块或服务：“依赖库存模块的InventoryService接口获取库存；依赖用户模块获取当前用户登录态。” 这一部分让测试人员知道测试范围内的被测代码有哪些，以及哪些外部接口需模拟。

依赖处理说明：针对上面列出的依赖，说明将在测试中如何处理。例如：“InventoryService接口在单元测试中将使用InventoryServiceStub模拟，其checkStock(productId)方法根据测试需要返回设定的库存数；用户登录状态可通过构造固定的用户会话对象模拟。” 提供这些细节确保测试人员能顺利搭建测试桩环境，不因依赖无法调用而受阻 。

测试用例建议：为该模块提供若干测试设计方面的建议和要点，以启发测试人员覆盖充分的情况  。这部分可以采用要点列表形式，包括正常场景、边界情况和异常情况等。例如，对于购物车模块，可提出：

功能场景： 测试添加商品到空购物车、添加到已有商品的购物车、删除购物车项、清空购物车等常规功能是否正确。

边界值： 测试购物车数量的边界（0件、1件、超过库存的数量、超出上限的数量）、购物车容量的上限（如果有规定上限）等。

异常处理： 模拟库存服务返回库存不足、商品不存在等异常情况，验证购物车模块能正确处理并给出相应提示。

业务规则： 测试同一商品多次加入是否合并数量，优惠计算（如果购物车负责计算价格则需验证）、空购物车结算行为等。

持久化与状态： 测试用户登录后购物车数据持久化是否正确（例如先添加商品再登录是否合并购物车），登出或超时后购物车处理等。 这些建议帮助测试人员全面设计测试用例，覆盖各类输入和场景。不仅关注“阳光路径”（正确输入产生预期结果），也覆盖“阴暗路径”（异常或边界输入的处理）。

注意事项和特殊要求：提醒任何在测试该模块时需要注意的事项或特殊准备。例如：

环境准备：是否需要特殊测试数据（如预置商品数据）、配置（如打开某开关来测试特定逻辑）、或者外部服务模拟（如需要启动一个本地假服务器）。

性能考虑：如果模块有性能要求，提示测试人员在单元测试中关注性能指标（虽然单元测试主要功能正确性，但也可做基本性能计时）或为将来性能测试做准备。

并发/多线程：如果模块包含并发逻辑，提醒在单元测试中使用线程或模拟并发场景进行测试。

日志和可调试性：告知该模块的重要日志点或错误码，以便调试时关注。

其他：任何模块特定的风险点、易错点（例如浮点计算精度、时区处理）都可以在此强调，帮助测试人员格外小心。

编写清单时要力求清晰、简明、全面。可以使用表格或分项列表格式，使内容一目了然，方便测试人员对照执行。清单既是任务说明，也是质量检查单——测试人员在完成模块测试后，可对照清单核实是否所有提及的点都已测试覆盖。完成的清单将交予各模块负责人，在测试执行前由测试组长或资深工程师评审，确保其完整性和正确性 。

接下来，提供一个测试任务清单模板示例，以更直观地说明最终交付给测试人员的任务说明应如何编写。

对每个模块输出 `features` 数组，每个 feature 至少包含：

- `name`: feature 名称（建议来自用例动作）
- `methods`: `Class.method` 列表（按时序顺序，入口在首）

现在你已经在内部完成了全部推理，接下来只需要**对外输出测试计划**，使用 JSON 格式，包含以下信息：

- `modules`: 模块列表，每个模块包含：
  - `module_id`: 模块的唯一标识（例如 "M1", "M2"...）
  - `name`: 模块的语义名称（例如 "OrderManagement", "InventoryService"），可以根据模块内职责自行命名
  - `classes`: 属于该模块的类名列表
  - `responsibility_summary`: 用简短自然语言描述该模块的核心职责（1–3 句）
  - `reasons`: 用简短自然语言总结本模块划分背后的关键考虑因素，例如：
    - 内聚性来源（共同支撑哪些用例 / 场景）
    - 与其他模块的主要交互及耦合控制
    - 与需求文档中哪些需求条目相关
  - `features`:该模块下细分的功能，每个feature包括一组相互合作完成一组功能需求的函数
  - `name`: feature name
  - `methods`: 该feature下的函数
  - `requirements:`:与该feature下函数相关的需求文档原文，可以冗余，不要遗漏

JSON 示例结构如下（只是结构示例，实际内容由你根据推理结果生成）：

```json
{
  "modules": [
    {
      "name": "OrderManagement",
      "classes": ["Order", "OrderItem", "OrderService","OrderDao"],
      "responsibility_summary": "负责订单的创建、修改、状态流转，并为支付和库存模块提供订单相关接口。",
      "reasons": {
        "cohesion": "这些类在订单创建、更新等场景中总是一起工作，类之间有大量方法调用和数据聚合关系。",
        "coupling": "跨模块主要与 Payment 和 Inventory 交互，已通过接口和领域边界控制依赖方向，减少不必要的跨模块耦合。",
        "requirements_trace": ["REQ-1 创建订单", "REQ-2 修改订单", "REQ-3 查询订单"]
      },
      "features":[
          {
              "name":"createOrder",
              "methods":[
                  "OrderService.createOrder",
                  "OrderDao.save"
              ],
              "requirements":"用户创建订单。。。；"
          }, {
              "name":"cancleOrder",
              "methods":[
                  "OrderService.cancleOrder",
                  "OrderDao.update"
              ] ,
              "requirements":"用户可以取消未支付的订单"
          }
      ]
    }
  ]
}
```