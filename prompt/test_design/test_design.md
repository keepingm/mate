你需要依据需求文档的描述，为指定的功能设计单元测试用例。
你必须完全依据需求来设计测试输入以及测试断言，不要涉及需求为提到的功能，不要遗漏需求的每一点细节。
请在**内部推理过程中**严格按照下面的思维步骤进行思考和决策，但在最终回答里**只输出 JSON 结果，不要暴露任何中间推理过程或步骤说明**。

【输入说明】
输入如下（以文本形式呈现）：
1.  被测方法签名和需求（list，你需要为每个方法设计多个测试用例）
{{sut}}


你需要在**内部思维链中**完成以下步骤：

第 1 步：理解 SUT 与需求语义
1.1 仔细阅读提供的：
被测方法所在的类名、方法名、参数列表、返回值类型；
该方法的业务需求描述（正常流程 + 异常行为）；
该方法依赖的其他服务、仓储、外部系统以及它们的业务规则。
1.2 总结这个方法完成了什么业务行为（一个工作单元 / unit of work）？对调用方来说，什么是“成功”的结果？什么是“失败”的结果？
第 2 步：分析输入空间并划分场景（正常 / 异常 / 边界）
2.1 列出 SUT 的所有输入：
方法参数（包括它们的类型和约束，比如不能为 null、必须 > 0 等）；
隐式输入（例如当前用户状态、数据库中是否已有记录等，可通过 mock 表达）。
2.2 根据业务规则把输入划分为等价类，并识别至少三类场景：
正常场景（Positive）：所有前置条件满足，业务应该成功；
异常场景（Negative/Exception）：某个前置条件不满足或依赖抛出异常，业务应该失败；
边界场景（Boundary）：接近临界值的输入，如数量 = 0、数量 = 最大库存、字符串为空、ID 不存在等。
2.3 为每一类场景选出一两个具有代表性的“样本输入”（参数具体值），保证：
正常场景至少 1 个；
异常场景至少 1 个（如找不到对象、库存不足、非法参数等）；
若需求中存在明显边界条件，则边界场景至少 1 个。
第 3 步：分析依赖与 mock 组合（step）
3.1 对于SUT 在执行过程中会用到的所有依赖（来自前一步的依赖链） 对每个测试场景，思考每个依赖在该场景下应该表现怎样的行为，用“mock 组合表”的方式在脑中枚举：
正常场景：
  依赖通常返回“合理有效”的数据；
  不应抛出异常；
  允许你通过 verify() 来断言它们确实被调用。
异常场景：
  至少一个依赖的行为需要被 mock 成“失败”：
    返回 null；
    返回空集合；
    抛出业务异常（如 StockNotEnoughException）；
  思考失败发生时，SUT 应该：
    抛出异常？
    返回错误码？
    终止后续依赖调用？
边界场景：
  mock 返回接近边界的数据，如：
    库存 = 请求数量；
    用户刚好不满足某个条件；
  观察是否触发特定分支逻辑。
第 4 步：为每个测试场景构造 Oracle（断言）
4.1 对每个测试场景，分别从以下三个维度设计预期结果（oracle）：
返回值断言：
  正常场景：检查返回对象的关键字段是否符合业务期望（如 userId、productId、qty、状态等）；
  异常场景：使用 assertThrows 检查是否抛出预期异常类型。
副作用 / 状态变化断言（通过 mock 交互体现）：
  使用 verify() 检查依赖是否被调用（或不被调用）；
  若重要，可以使用 ArgumentCaptor 捕获传入依赖的方法参数并检查其字段。
调用顺序断言（可选）：
  如果业务对顺序敏感，使用 InOrder 验证依赖调用顺序；
  例如：先 checkStock，再 deductStock，再 save，再 notify。
4.2 确保每个测试场景的 oracle 是“可观察”的，不依赖于私有字段或内部实现细节：
不要直接断言私有状态；
更侧重于返回值、mock 交互、调用次数和顺序。
第 5 步：把场景 + mock + oracle 映射为 JUnit 测试方法
5.1 为每个场景设计一个清晰的测试方法名，建议格式：
methodName_when前置条件_should期望结果
  例如：  placeOrder_whenStockIsEnough_shouldCreateOrderAndNotifyUser
5.2 每个测试方法内分成 3 个逻辑区块：
Arrange：
  配置所有 mock 的行为（when / doThrow 等）；
  构造输入参数；
  不要遗漏任何依赖的必要模拟。
Act：
  生成测试前缀，将被测方法驱动到可测状态，调用被测方法（SUT）并捕获返回值或异常。
Assert：
  对返回值进行 assertEquals / assertNotNull / assertThrows 等断言；
  使用 verify() 检查依赖调用；
  必要时使用 ArgumentCaptor 和 InOrder。
5.3 思考是否需要公用的测试数据或初始化逻辑，若需要则：
使用 @BeforeEach 初始化；
或者使用私有方法构造公共测试对象（例如构造一个 Product、Order 等）。
6. 以文本格式输出测试用例